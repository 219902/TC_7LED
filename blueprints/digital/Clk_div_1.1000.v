/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module counter (
  input Enable,
  input D_0,
  input D_1,
  input D_2,
  input D_3,
  input Load,
  input Clock,
  output Q_0,
  output Q_1,
  output Q_2,
  output Q_3,
  output Z
);
  wire s0;
  wire Q_0_temp;
  wire s1;
  wire Q_1_temp;
  wire s2;
  wire Q_2_temp;
  wire s3;
  wire Q_3_temp;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i0 (
    .D( s0 ),
    .C( Clock ),
    .Q( Q_0_temp )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i1 (
    .D( s1 ),
    .C( Clock ),
    .Q( Q_1_temp )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i2 (
    .D( s2 ),
    .C( Clock ),
    .Q( Q_2_temp )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i3 (
    .D( s3 ),
    .C( Clock ),
    .Q( Q_3_temp )
  );
  Mux_2x1 Mux_2x1_i4 (
    .sel( Load ),
    .in_0( s4 ),
    .in_1( D_0 ),
    .out( s0 )
  );
  Mux_2x1 Mux_2x1_i5 (
    .sel( Load ),
    .in_0( s5 ),
    .in_1( D_1 ),
    .out( s1 )
  );
  Mux_2x1 Mux_2x1_i6 (
    .sel( Load ),
    .in_0( s6 ),
    .in_1( D_2 ),
    .out( s2 )
  );
  Mux_2x1 Mux_2x1_i7 (
    .sel( Load ),
    .in_0( s7 ),
    .in_1( D_3 ),
    .out( s3 )
  );
  assign s8 = (Q_0_temp & Enable);
  assign s4 = (Q_0_temp ^ Enable);
  assign s9 = (Q_1_temp & s8);
  assign s5 = (Q_1_temp ^ s8);
  assign s10 = (Q_2_temp & s9);
  assign s6 = (Q_2_temp ^ s9);
  assign Z = (Q_3_temp & s10);
  assign s7 = (Q_3_temp ^ s10);
  assign Q_0 = Q_0_temp;
  assign Q_1 = Q_1_temp;
  assign Q_2 = Q_2_temp;
  assign Q_3 = Q_3_temp;
endmodule

module \Clk_div_1.1000  (
  input Clock,
  input Reset,
  output \Output 
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire Output_temp;
  counter counter_i0 (
    .Enable( 1'b1 ),
    .D_0( 1'b0 ),
    .D_1( 1'b0 ),
    .D_2( 1'b0 ),
    .D_3( 1'b0 ),
    .Load( s0 ),
    .Clock( Clock ),
    .Q_3( s1 ),
    .Z( s2 )
  );
  counter counter_i1 (
    .Enable( s2 ),
    .D_0( 1'b0 ),
    .D_1( 1'b0 ),
    .D_2( 1'b0 ),
    .D_3( 1'b0 ),
    .Load( s0 ),
    .Clock( Clock ),
    .Q_1( s3 ),
    .Q_2( s4 ),
    .Q_3( s5 ),
    .Z( s6 )
  );
  counter counter_i2 (
    .Enable( s6 ),
    .D_0( 1'b0 ),
    .D_1( 1'b0 ),
    .D_2( 1'b0 ),
    .D_3( 1'b0 ),
    .Load( s0 ),
    .Clock( Clock ),
    .Q_0( s7 ),
    .Q_1( s8 )
  );
  assign s0 = (Output_temp | Reset);
  assign Output_temp = (s1 & (s3 & s4 & s5) & (s7 & s8));
  assign \Output  = Output_temp;
endmodule
